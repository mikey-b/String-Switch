# String Switch

[Godbolt Example Link](https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQWm8GA6dUqqgYEAysib0QARgAsAoQQCqAZ0wAFAB4gA5AAZtpAFbTStJg1DIApACYAQrbulV9ZATxDKjdAGFUtAFcWBhAAdlJvABluTAA5IIAjTGIQADZSAAdUZUIPBj9A4LDM7NyhaIY4xOS050xXdyERAiZiAgKgkPCXTDc85taCCqqWJJT05Ra2jqLuqaGY%2BNGa1IBKZ1QA4mR2bVsAZm5kQKwrfZ9kSfxUM%2BwrXQBBe4fGIIBqEQAVB8/sERA3gEGDlgJV0G9kAhWm8rKEHI83oi3gBJWLIz6kZ5It4JUg4ph4pJ45DEgkQpj8HGYSkJCmYhFIgAa9Ie2PE6AA%2BkxkDsMgRCdSuTzMHzCRShbz%2Bc9YQARM7wp6PNDAgiYDQZYgfb6/ERvFoJehWACsdlCxrlJoAnOaYfsZTC4VikbC7G9mfi8e73eJPb63Z7ZXjscGQ6HEQB6cNvJhOxEunF%2Br2J5NuwNh9MZyM42MO10k/0FpOFxNpjNl4NZ6wMuNw4v4mnUv3slOM0vl0NZ9A5%2BPuol1osDtvtzNRzDd2sDlukdkSkX8pKc7mS0i0xfCvltrOxRSRceuyf9luy4fDrMPBgATwICG4wDe9VU0tCcv2Cueysmao1b24BAhUO2MxlGUCBIWhPBkFWXMcyzaIWEIPUEEwPUmANZD0FQAB3Bg9VQRDkLA4huVVYhlDeC9NmjNwAgkWgLzeSpqR4N4AHVCAQN4hGQsBtFQa9kjeAA3CQAmQiAjR/HDrzwMi1VYDJ6FWHM8CoN4IAg20X3tXQoOITACC2HCjXlZTVKgDTbjeHjMB4qDYR8ey1Is84rO0JhbN0/TDLeVITOrN49IM4gcPU5A3gAWlc9ztCU18nzlR53yET91U1X9JKwDRQOSv9CIAKjeZQ7MdfymACIg3iyMizntVF0T81kkQw3NKuyTSULQ407EI44mGAiA8uURxHCUo0LTsKrzXlB17Uwm96AgKrbR8N1YoVbFAu8pbItbV83lg/SyOUG8qD/fjOPKjJytwqk3l0UgpFIGxSH2eLpUedLOG4dThGjYhgHzfKCtaYBBOK9akUjPKCo/VVUreTCSAAazImhKjxAJVEQmSfxu1RkMwQTkivG8LAhVAWD5PA2GjTCmAvZjoZgqNYf/aE8tZvB2tsGwFx5hrmbeAB5TVMeQkHBNMtSQbCs4VpsTygpw3QGrZHK2eIAquZqv7Qa6qQprixL/KhgrlEwwhITeDDMCO9xaFoN4oSJ6McJU8KwO4PFVUmW83kETV7se579kZvLu3883LYQH7MvU1ZwZzNk%2BuQ7g4559kedWAF4w1X8qAgHnBCBcFM6NHwGCz6aEj0pgkem2Uk6RcQsbTtVC5sXnqSznPazz4QC6LzYGHBPny8rzu1pxWv672xv/OT1uR/bnnVx7lr%2B4IQfO%2BLkf62NCuq72mvMDrhvnybxEsCoMraAIXvXU37ebEUBgkYYLDK/Ho/XRPs%2B54vv5eejU4zGxAftcM0M3gPDvskZg7giZ0TxEwN4hgggZA6vQBGdBHYf0wgjZGYcYLh0ji0dwYVWaCVQHgdABVDCUwIAaLqNodbxlsL5GwqRIjX1vvyGEnD2GRGbPwjhXCFx4nYYI1cM1VZImAHxVAdCGFMJNG3LKeBRovjfP5IRFIH6VWIPnDuNhd6lwpAfCeCtpryIqtwri58ErgMiAufRT9jGmKpF2b%2Bk9rEKLeHYyoDiczOL0RvQxA93HD1HuY7xVi9o2LwgEscADHHYm4ZgG%2BAQ76uPCVvYxr936fwsT/N4CT/EYUCSk4JFT2DQUAeAvK4Z4oxVMDoI0BgQh6AMKgDgXBeD8Hvl0hOpAkIUhqBAdYSMQBGnurQHQMgOk6H0KQHp2gDDKBAPdQZ%2Bh1hwFgDARAKAKYZDoMkcglA0CU1OSkXqFgpCpF0PdLAgkIKYAAGp4EwJhIWGRGA6CkAYGgsDSKUASEsgwCRuCtAvP8iFULiAXiFgkQwvRBkAunBTNgwghYMDouC0gWBOAWEkF0gleA9J9CJhs0lapejlV2Oi389R8W0DwDXaFfgsD4oIIYlgsL1hUDMMAZQHyvk/L%2BdodFghhBiAkOwWQ8hhAqHUFoUlxhHpmAsCgYa9hTBso2ZAdYqAqbJR0OFIWNh1n1FRXkLwI8ZghEelERY1QUiPSqmUfI/hOgmA9Y0BgwwlhjBMD0PoTR5gOpDdasNDABhtEDa6kNEbvVFEepMQYCblhuvWMoTY2x5XrDmdodppBOnLNWW8DQAAOVI4VUgyAhJqu89yeC6FbWpXAhASD8P2FIVYBhtkxXWKMrAKQJmtO0As0gfL608BsPsUIUh50yBsLoUIlpUiWlLfi1Z6zNmkEHbsg5EAkC0uQOVEg5yIAg2UGocw9QRAIE/viy5JyzD%2BrvZUWgj7n2SoMK%2B65IBgBSCXRiq59BiCxFYLsf9xzrlC3Kj%2B7CsKIgaF6A8f6GzVz8DPc0fAnTAUKFlZIBV0qlCqE0Pi9VphzCWB1U4VlCQDXjuNf66l6y807CTfhz9D6n3Ib/QevSDKDCYSIhkflE6S1lu6TobAaHz1EE1NW2t9bSk8jeCBudakHL2EcHiTtSme19oHeC4ZI7xmTOmbM%2BZBg%2BX7CNDwUIqQbBVuc0addq7e2PRkysnQe6tlmaszMid%2BxFmkt3QeoLE7LXboi/5qLQz1hE1IramQQA%3D%3D%3D)

This is a technique to allow you to have a switch case feature that supported strings.

For example,

```d
int foo(string i) {
    switch(i) {
        case "cad":
            return 7;

        case "bed":
            return 13;

        case "bad":
            return 42;

        default:
            return 0;
    }
}
```

This method is O(m) - where m is the longest case string length. The case strings must be constant. 



Rather than using an if chain - testing the input against each individual case with strcmp(), we are going to use a DFA that's encoded into a table.



**Table**

```cpp
enum STATES: unsigned char {
    INIT,
    b, ba, be, c, ca, cad, bed, bad,
    X,
    cad_accept, bed_accept, bad_accept,
};

constexpr STATES table[7][9] = {
    { X, ba, X, X, ca, X, X, X, X},                         // a
    { b, X, X, X, X, X, X, X, X},                           // b
    { c, X, X, X, X, X, X, X, X},                           // c
    { X, X, bad, bed, X, cad, X, X, X},                     // d
    { X, be, X, X, X, X, X, X, X},                          // e
    { X, X, X, X, X, X,cad_accept,bed_accept,bad_accept},   // NUL
    { X, X, X, X, X, X, X, X, X}                            // Anything else
};

constexpr int charclass(char ic) {
    // Limit the table down to the characters you actually need. With one 'other value (5 in this example)
    if (ic == 0) return 5;
    if ((ic > 'e') || (ic < 'a')) return 6;
    return (ic - 'a');
}
```

This table is compressed, which is beneficial but not necessary. We are using charclass() to narrow the values of the input down to smaller range (0 to 6).



**Table Element "State" Values**

The values within the table represent a state within the DFA. These are split into three groups;

1) The first set represent states that are partial matches, and will continue to consume the input. 

2) The second set/value, X, represents a non matching string. 

3) The third set are result states, representing "cad", "bed", and "bad" in this example.

The value zero is reserved for the initial state of the DFA. 



**Table Rows and Columns**

Rows are "characters", and columns is the current state the DFA is in. `table[7][9]` says we accept 7 unique characters (a,b,c,d,e,NUL,*), and there are a total of 9 partial match states.



One row is a letter in the valid letter range, defined by the charclass. E.g. a = 0, b = 1, c = 2, d = 3, e = 4, NUL = 6, anything else = 6.



**Generating The Table**

1. Determine the state sets, {INIT} {partial matches} {X} {matches}

2. Set the table height to be the range returned by charclass ( 0 to 6 is [7] )

3. Set the table width to be the size of the INIT + partial matches sets ( INIT, b, ba, be, c, ca, cad, bed, bad is [9] )

4. We start by filling all entries in the table with `X`

5. Starting at column zero (`INIT`), enter any valid states that can be transitioned from this position (which are `b` and `c`). 

6. Now move right one column, this corresponds to state `b` (the enum value is the offset into the table), now enter the valid transitions from this state position (which are`ba` and `be`)

7. Repeat step 6 until all states are filled.



**Processing**

index() turns a string into an integer, which corresponds to the accepted STATES table values (or 0,1,2,3 as below).

Starting at column 0 (`INIT`), we process the input on char at a time, we move left to right along the table.

```cpp
constexpr int index(const char* s) {
    auto pos = INIT;
    do { pos = table[charclass(*s++)][pos]; } while(pos < X);
    return pos - X; // Lets shift the output to be 0,1,2,3
}
```

If the input s was "bed", pos would be `INIT => b => be => bed => bed_accept` through the loop.

If the returned state value is higher than `X` - if we have a non-match or a valid matching state (`cad_accept`, `bed_accept`, `bad_accept`), we exit the loop.

If you are going to use a jump table, you might want to shift the results so the lowest value returned is zero.



**Further Thoughts**

* This method supports ranges easily, Complete the table as normal but return the same accept state at the end

* If your string has the length precomputed, adding a test for the `if (i.length > m)` might be beneficial.

* If your strings are not null terminated, you will have to adjust the loop in index() and fixup to the non-matching value
